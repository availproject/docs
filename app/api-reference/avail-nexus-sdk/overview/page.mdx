---
title: "Get Started"
---

import { Callout, Steps, Tabs } from 'nextra/components';

# Get Started

<Callout type="info">
    We built a React demo app that uses the Avail Nexus SDK UI widgets to implement a unified Web3 experience.

    1. You can use the app here: [`nexus-ui-components-demo.vercel.app`](https://nexus-ui-components-demo.vercel.app/)
    2. You can find the code for the app here: [`availproject/nexus-ui-components-demo`](https://github.com/availproject/nexus-ui-components-demo)
</Callout>


This page helps you do two things, with both the Core (headless) SDK and the React UI widgets:
1) Initialize the SDK and view unified balances
2) Send your first transaction (transfer/bridge)

<Callout type="info">
**MAKE SURE YOUR DEV ENVIRONMENT IS SET UP BEFORE PROCEEDING**<br/>

Go through this [page in our docs](/api-reference/avail-nexus-sdk) for more details.
</Callout>

### Initialize the SDK

<Tabs items={['Core (Headless)', 'UI Widgets']}>

<Tabs.Tab>

1. Import the SDK and initialize it with the network you want to use.
2. Inject the wallet provider into the SDK.

<Callout type="info">
**LOOKING FOR LIST OF SUPPORTED NETWORKS?**<br/>
Check out our [API reference](/api-reference/avail-nexus-sdk/api-reference#supported-chains) for a complete list.
</Callout>

```ts showLineNumbers filename="Initialize-Core"
import { NexusSDK, type NexusNetwork } from '@avail-project/nexus/core';

const network: NexusNetwork = 'mainnet'; // or 'testnet', default is 'mainnet'
const sdk = new NexusSDK({ network });

// Injecting the wallet provider into the SDK
await sdk.initialize(window.ethereum);
```
</Tabs.Tab>

<Tabs.Tab>

1. Wrap your app with the `NexusProvider` at the root of your app.
For example, this is how you would do it in a Next.js app using the `app` directory:

```tsx showLineNumbers filename="layout.tsx"
import { NexusProvider } from '@avail-project/nexus/ui';

export default function Root() {
  return (
    <NexusProvider
      config={{
        network: 'testnet', // "mainnet" (default) or "testnet"
      }}
    >
      <App />
    </NexusProvider>
  );
}
```

Once the `NexusProvider` is set up, you have two ways to initialize the SDK:

- **Auto Initialization**: 
The UI widgets handle the SDK initialization for you. You just need to forward the wallet provider
using the `setProvider` function. When you next use a widget, the SDK will be initialized automatically.

- **Manual Initialization**: You can also explicitly call the `initializeSdk(provider)` function to
have a finer control over when the SDK is initialized.

<details className="border p-3 rounded-md bg-[#EFF6FF]">
<summary>Why would you want to manually initialize the SDK?</summary>

The first question that might come to mind is why would a dev bother 
with manual initialization when the SDK does provide an option to have it done automatically under the hood.

1. If the SDK is first initialized when you use a widget, you can't use it to fetch unified balances before a widget is used, since the SDK is not initialized yet.
So if your app needs to display unified balances before a widget is used, you need to manually initialize the SDK.

2. The initialized state of the SDK is stored in the UI state, so the widget
will not need to re-initialize the SDK when they are used.
</details>

<Tabs items={['Auto Initialization', 'Manual Initialization']}>

<Tabs.Tab>

Forward the user's wallet provider and drop a widget into your UI.
The UI widgets handle the SDK initialization for you.

The following example shows how you would use the bridge button, but other widgets are covered in the following pages:

```tsx showLineNumbers filename="WalletBridge.tsx"
// Complete example showing both wallet provider setup AND widget usage
import { useEffect } from 'react';
import { useAccount } from '@wagmi/react';
import { useNexus, BridgeButton } from '@avail-project/nexus/ui';

function MyApp() {
  const { connector, isConnected } = useAccount();
  const { setProvider } = useNexus();

  // Forward wallet provider
  useEffect(() => {
    if (isConnected && connector?.getProvider) {
      connector.getProvider().then(setProvider);
    }
  }, [isConnected, connector, setProvider]);

  // Use UI widgets (initialization happens automatically)
  return (
    <BridgeButton prefill={{ chainId: 137, token: 'USDC', amount: '100' }}>
      {({ onClick, isLoading }) => (
        <button onClick={onClick} disabled={isLoading}>
          {isLoading ? 'Bridging…' : 'Bridge 100 USDC → Polygon'}
        </button>
      )}
    </BridgeButton>
  );
}
```

<Callout>
**Any wallet library works:** The example shows Wagmi, but you can use Privy, RainbowKit, ConnectKit, or any library that provides an EIP-1193 provider.

The demo app uses Privy and forwards the provider in [connect-wallet.tsx](https://github.com/availproject/nexus-ui-components-demo/blob/main/src/components/connect-wallet.tsx#L16).
</Callout>

</Tabs.Tab>

<Tabs.Tab>

You can also manually initialize the SDK instead of leaving it up to the UI widgets.
The code snippet below shows how:

<Callout>
You still need to wrap your app with the `NexusProvider` before proceeding with the manual initialization.
</Callout>

```tsx showLineNumbers filename="App.tsx"
import { useNexus } from '@avail-project/nexus/ui';

function MyComponent() {
  const { initializeSdk, sdk, isSdkInitialized } = useNexus();

  const handleInitialize = async () => {
    const provider = await window.ethereum; // or get from your wallet library
    await initializeSdk(provider); // Initializes both SDK and UI state

    // Now you can use SDK methods directly
    const balances = await sdk.getUnifiedBalances();
    console.log('Balances:', balances);

    // UI widgets will already be initialized when used
  };

  return (
    <button onClick={handleInitialize} disabled={isSdkInitialized}>
      {isSdkInitialized ? 'SDK Ready' : 'Initialize SDK'}
    </button>
  );
}
```

<Callout type="info">
**WHAT THIS MEANS?**<br/>

1. The `useNexus` hook now shares the initialized SDK instance with the UI widgets.
2. You can initialize the SDK manually, and then use the UI widgets to sign transactions.
3. With the shared state, just one signature is needed to initialize the SDK and use the UI widgets.
</Callout>

</Tabs.Tab>

</Tabs>

</Tabs.Tab>

</Tabs>

<Callout type="info">
**FOR EXAMPLE:**<br/>

The demo app sets up the `NexusProvider` in the [__root.tsx](https://github.com/availproject/nexus-ui-components-demo/blob/main/src/routes/__root.tsx#L50) file, 
wrapping the entire application with both wallet authentication (Privy) and the Nexus provider.
</Callout>

<details className="border p-3 rounded-md bg-[#EFF6FF]">
<summary>What do we mean by "unified balance"?</summary>

Unified balance shows all the liquidity in a user's EOA account across multiple chains in one view. It lets users transact seamlessly on any chain without needing bridges or pre-provisioning gas for token swaps. Chain abstraction handles all the complexity involved in a cross-chain transaction while enabling better UX through a single intent approval.

For instance, let us take the case where a user intends to spend 18 USDC on Scroll and does not have any balance on Scroll.

- Optimism: 0.1 ETH, O USDT, 0 USDC
- Arbitrum: 0 ETH, 12 USDT, 0 USDC
- Base: 0 ETH, 10 USDT, 0 USDC
- Scroll: 0 ETH, 0 USDT, 0 USDC

To spend 18 USDC on Scroll (destination chain) with the given liquidity fragmentation, it would typically require multiple clicks and steps for swapping or bridging different assets available on the source chains, so that user can convert the assets to the desired token balance on Scroll.

Through chain abstraction and ability to swap cross-chain, users have the convenience to view the consolidated token balance across supported tokens and chains. This simplifies the process of sending 18 USDC on Optimism, as users can sign the intent without the need for bridging, swapping, or considering the optimal routes.

The cross-chain swap enables users to:

- Spend assets on any destination chain without prior liquidity.
- Collate payable amount by combining multiple supported assets across source chains to address liquidity fragmentation.
</details>