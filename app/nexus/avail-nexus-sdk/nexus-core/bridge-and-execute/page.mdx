---
title: "Bridge and execute a transaction using the Nexus SDK"
---

import { Callout, Steps, Tabs } from 'nextra/components'

# `bridgeAndExecute()`

<Callout type="info">
**SET UP THE SDK BEFORE YOU START:**

1. You can find the SDK setup instructions in the [Quickstart](/nexus/nexus-quickstart) page.
2. We also [created a tutorial](/nexus/nexus-examples/nexus-initialization-basic) to make it easier to understand how devs need to initialize the Nexus SDK in their project.
</Callout>

The `bridgeAndExecute` method enables **atomic cross-chain operations** - allowing you to bridge assets from one chain to another and immediately execute a smart contract call in a single transaction. This eliminates the need for multiple steps and reduces the risk of MEV attacks, failed transactions, or price slippage that can occur when bridging and executing separately.

### Key Benefits

- **Atomic Execution**: Both the bridge and subsequent operation succeed or fail together
- **Reduced Complexity**: Single transaction instead of multiple steps
- **Improved User Experience**: Users get their desired outcome in one interaction
- **Cost Efficiency**: Potentially lower overall gas costs
- **MEV Protection**: Minimizes front-running opportunities

### Common Use Cases

- Bridging tokens and immediately swapping to another token
- Cross-chain yield farming deposits
- Bridging NFTs and listing them on a marketplace
- Cross-chain liquidity provision
- Bridging and staking in one transaction

## How It Works

The `bridgeAndExecute` process follows this sequence:

### Step 1: Initiation
Your dApp calls the `bridgeAndExecute` method with both the bridging parameters and the execution payload for the destination chain.

### Step 2: Source Chain Processing
- Tokens are locked or burned on the source chain
- Bridge message is emitted with both the asset transfer details and execution instructions

### Step 3: Cross-Chain Messaging
The bridge protocol relays the message to the destination chain, ensuring the execution payload is included.

### Step 4: Atomic Execution on Destination
On the destination chain:
1. Tokens are minted or released to the user
2. The specified contract is immediately called with the provided calldata
3. Both operations are atomic - if either fails, the entire transaction reverts

### Step 5: Confirmation
Your application receives a response with transaction details to track the operation.

## Method signature

```typescript showLineNumbers filename="Typescript"
async bridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteResult>
async simulateBridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteSimulationResult>
```

## Parameters

```typescript showLineNumbers filename="Typescript"
export interface BridgeAndExecuteParams {
  toChainId: SUPPORTED_CHAINS_IDS;
  token: SUPPORTED_TOKENS;
  // Token address on source chain
  amount: number | string;
  recipient?: `0x${string}`;
  sourceChains?: number[];
  execute?: Omit<ExecuteParams, 'toChainId'>;
  enableTransactionPolling?: boolean;
  transactionTimeout?: number;
  // Global options for transaction confirmation
  waitForReceipt?: boolean;
  receiptTimeout?: number;
  requiredConfirmations?: number;
  // Optional recent approval transaction hash to consider in simulation
  recentApprovalTxHash?: string;
}
```

## Handling responses

The `bridgeAndExecute` call returns a `BridgeAndExecuteResult` [object](). You can use its fields to show status to users or to poll block explorers for progress.

Note that the `bridgeAndExecute` method handles responses differently depending on the bridge protocol and chain configurations. Below are minimal examples on how you can work with the responses.

### Immediate confirmation bridges

Some bridges (like those with instant finality or optimistic execution) provide immediate confirmation:
Use the hashes and explorer URLs returned by the bridge call to surface immediate confirmations. The bridge transaction hash is available right away, so you can link to it and begin polling while the destination execution continues.

```typescript
import { NexusSDK } from '@avail-project/nexus-core';
import type { BridgeAndExecuteResult } from '@avail-project/nexus-core';

const sdk = new NexusSDK(/* ... */);

const result: BridgeAndExecuteResult = await sdk.bridgeAndExecute(params);

if (result.success) {
  // Show immediate bridge confirmation
  if (result.bridgeTransactionHash && result.bridgeExplorerUrl) {
    console.log(`Bridge submitted: ${result.bridgeExplorerUrl}`);
  }

  // Track follow-up approval or execution hashes when present
  if (result.approvalTransactionHash) {
    console.log(`Approval tx: ${result.approvalTransactionHash}`);
  }
  if (result.executeTransactionHash && result.executeExplorerUrl) {
    console.log(`Execute tx: ${result.executeExplorerUrl}`);
  }
} else {
  console.error(`Bridge and execute failed: ${result.error}`);
}
```

**What to do with the response in your user experience**
- Use the bridge hash/URL to show an immediate “bridge submitted” banner.
- Start polling the bridge transaction for completion on the source chain.
- Surface execution details (hash/URL) when available to help users follow the destination action.

### Destination chain finality bridges

For bridges that only finalize after the destination chain confirms the execution, rely on the destination transaction hash to track finality. The response flags whether the bridge step was skipped and always includes the target chain ID so you can pick the correct explorer.

```typescript
import { NexusSDK } from '@avail-project/nexus-core';
import type { BridgeAndExecuteResult } from '@avail-project/nexus-core';

const sdk = new NexusSDK(/* ... */);

const result: BridgeAndExecuteResult = await sdk.bridgeAndExecute({
  ...params,
  waitForReceipt: true,           // wait for receipt on the destination chain
  requiredConfirmations: 3,       // enforce destination finality
});

if (result.success) {
  // Bridge may be skipped if funds already exist on the destination
  if (result.bridgeSkipped) {
    console.log('Bridge skipped; executed directly on destination chain');
  }

  // Wait for the destination execution to reach finality
  if (result.executeTransactionHash) {
    await pollForConfirmations({
      txHash: result.executeTransactionHash,
      chainId: result.toChainId,
      minConfirmations: 3,
    });
    console.log('Destination execution finalized');
  }
} else {
  console.error(`Bridge and execute failed: ${result.error}`);
}

```

**What to do with the response in your user experience**
- Respect `bridgeSkipped` to avoid showing bridge progress when the SDK executes directly.
- Use `toChainId` and the execution hash to poll the destination chain until the required confirmations are met.
- Present finality status updates (e.g., “Waiting for 3 confirmations on chain X”).

## Examples

### Example 1

The following examples showcases the use of the `bridgeAndExecute` call. The example bridges USDC from Base to Ethereum and then deposits the USDC to the `Yearn USDC Vault`.

```typescript showLineNumbers filename="Typescript"
import type {
  ExecuteParams,
  ExecuteResult,
  ExecuteSimulation,
  BridgeAndExecuteParams,
  BridgeAndExecuteResult,
  BridgeAndExecuteSimulationResult,
} from '@avail-project/nexus-core';

// Execute contract functions with dynamic parameter builder - Compound V3 Supply
const result: ExecuteResult = await sdk.execute({
  toChainId: 1,
  contractAddress: '0xc3d688B66703497DAA19211EEdff47f25384cdc3', // Compound V3 USDC Market
  contractAbi: [
    {
      inputs: [
        { internalType: 'address', name: 'asset', type: 'address' },
        { internalType: 'uint256', name: 'amount', type: 'uint256' },
      ],
      name: 'supply',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  functionName: 'supply',
  buildFunctionParams: (
    token: SUPPORTED_TOKENS,
    amount: string,
    chainId: SUPPORTED_CHAINS_IDS,
    userAddress: `0x${string}`,
  ) => {
    const decimals = TOKEN_METADATA[token].decimals;
    const amountWei = parseUnits(amount, decimals);
    const tokenAddress = TOKEN_CONTRACT_ADDRESSES[token][chainId];
    return {
      functionParams: [tokenAddress, amountWei],
    };
  },
  waitForReceipt: true,
  requiredConfirmations: 3,
  tokenApproval: {
    token: 'USDC',
    amount: '1000000', // Amount in token units
  },
} as ExecuteParams);

// Simulate execute to preview costs and check for approval requirements
const simulation: ExecuteSimulation = await sdk.simulateExecute(executeParams);
if (!simulation.success) {
  console.log('Simulation failed:', simulation.error);
  // Error might indicate missing token approval
}

// Bridge tokens and execute contract function - Yearn Vault Deposit
const bridgeAndExecuteResult: BridgeAndExecuteResult = await sdk.bridgeAndExecute({
  token: 'USDC',
  amount: '100000000', // 100 USDC (6 decimals)
  toChainId: 1, // Ethereum
  sourceChains: [8453], // Only use USDC from `Base` as source for bridge
  execute: {
    contractAddress: '0xa354F35829Ae975e850e23e9615b11Da1B3dC4DE', // Yearn USDC Vault
    contractAbi: [
      {
        inputs: [
          { internalType: 'uint256', name: 'assets', type: 'uint256' },
          { internalType: 'address', name: 'receiver', type: 'address' },
        ],
        name: 'deposit',
        outputs: [{ internalType: 'uint256', name: 'shares', type: 'uint256' }],
        stateMutability: 'nonpayable',
        type: 'function',
      },
    ],
    functionName: 'deposit',
    buildFunctionParams: (
      token: SUPPORTED_TOKENS,
      amount: string,
      chainId: SUPPORTED_CHAINS_IDS,
      userAddress: `0x${string}`,
    ) => {
      const decimals = TOKEN_METADATA[token].decimals;
      const amountWei = parseUnits(amount, decimals);
      return {
        functionParams: [amountWei, userAddress],
      };
    },
    tokenApproval: {
      token: 'USDC',
      amount: '100000000',
    },
  },
  waitForReceipt: true,
} as BridgeAndExecuteParams);

// Comprehensive simulation with detailed step analysis and approval handling
const simulation: BridgeAndExecuteSimulationResult = await sdk.simulateBridgeAndExecute(params);

// The simulation provides detailed step analysis:
console.log('Steps:', simulation.steps);

console.log('Total estimated cost:', simulation.totalEstimatedCost);

console.log('Approval required:', simulation.metadata?.approvalRequired);
console.log('Bridge receive amount:', simulation.metadata?.bridgeReceiveAmount);
```

### Example 2

The following examples showcases the use of the `bridgeAndExecute` call. The example bridges native ETH from Arbitrum and stakes it in the `Lido stETH` vault on Ethereum. 

Only the `bridgeAndExecute` call part of the first example has changed. Note that native ETH deposit does not require setting `tokenApproval`. 

```typescript
...

// Bridge native ETH from Arbitrum and stake into Lido stETH on Ethereum
const lidoStakeResult: BridgeAndExecuteResult = await sdk.bridgeAndExecute({
  token: 'ETH',
  amount: '0.5', // Bridge 0.5 ETH
  toChainId: 1, // Stake on Ethereum mainnet
  sourceChains: [42161], // Bridge from Arbitrum
  execute: {
    contractAddress: '0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84', // Lido stETH
    contractAbi: [
      {
        inputs: [{ internalType: 'address', name: '_referral', type: 'address' }],
        name: 'submit',
        outputs: [{ internalType: 'uint256', name: 'stETH', type: 'uint256' }],
        stateMutability: 'payable',
        type: 'function',
      },
    ],
    functionName: 'submit',
    buildFunctionParams: (
      token: SUPPORTED_TOKENS,
      amount: string,
      chainId: SUPPORTED_CHAINS_IDS,
      userAddress: `0x${string}`,
    ) => {
      const amountWei = parseUnits(amount, 18);
      return {
        // Stake without referral and send the bridged ETH as msg.value
        functionParams: ['0x0000000000000000000000000000000000000000'],
        value: amountWei.toString(),
      };
    },
  },
  waitForReceipt: true,
} as BridgeAndExecuteParams);
...

```

## Return Value

The return value is a `BridgeAndExecuteResult` object.

```typescript showLineNumbers filename="Typescript"
export interface BridgeAndExecuteResult {
  executeTransactionHash?: string;
  executeExplorerUrl?: string;
  approvalTransactionHash?: string;
  bridgeTransactionHash?: string; // undefined when bridge is skipped
  bridgeExplorerUrl?: string; // undefined when bridge is skipped
  toChainId: number;
  success: boolean;
  error?: string;
  bridgeSkipped: boolean; // indicates if bridge was skipped due to sufficient funds
}
```