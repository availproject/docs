---
title: "Bridge and execute a transaction using the Nexus SDK"
---

import { Callout, Steps, Tabs } from 'nextra/components'

# `bridgeAndExecute()`

<Callout type="info">
**SET UP THE SDK BEFORE YOU START:**

1. You can find the SDK setup instructions in the [Quickstart](/nexus/nexus-quickstart) page.
2. We also [created a tutorial](/nexus/nexus-examples/nexus-initialization-basic) to make it easier to understand how devs need to initialize the Nexus SDK in their project.
</Callout>

The `bridgeAndExecute` method enables **atomic cross-chain operations** - allowing you to bridge assets from one chain to another and immediately execute a smart contract call in a single transaction. This eliminates the need for multiple steps and reduces the risk of MEV attacks, failed transactions, or price slippage that can occur when bridging and executing separately.

### Key Benefits

- **Atomic Execution**: Both the bridge and subsequent operation succeed or fail together
- **Reduced Complexity**: Single transaction instead of multiple steps
- **Improved User Experience**: Users get their desired outcome in one interaction
- **Cost Efficiency**: Potentially lower overall gas costs
- **MEV Protection**: Minimizes front-running opportunities

### Common Use Cases

- Bridging tokens and immediately swapping to another token
- Cross-chain yield farming deposits
- Bridging NFTs and listing them on a marketplace
- Cross-chain liquidity provision
- Bridging and staking in one transaction

## How It Works

The `bridgeAndExecute` process follows this sequence:

### Step 1: Initiation
Your dApp calls the `bridgeAndExecute` method with both the bridging parameters and the execution payload for the destination chain.

### Step 2: Source Chain Processing
- Tokens are locked or burned on the source chain
- Bridge message is emitted with both the asset transfer details and execution instructions

### Step 3: Cross-Chain Messaging
The bridge protocol relays the message to the destination chain, ensuring the execution payload is included.

### Step 4: Atomic Execution on Destination
On the destination chain:
1. Tokens are minted or released to the user
2. The specified contract is immediately called with the provided calldata
3. Both operations are atomic - if either fails, the entire transaction reverts

### Step 5: Confirmation
Your application receives a response with transaction details to track the operation.

## Method signature

```typescript showLineNumbers filename="Typescript"
async bridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteResult>
async simulateBridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteSimulationResult>
```

## Parameters

```typescript showLineNumbers filename="Typescript"
export interface BridgeAndExecuteParams {
  toChainId: SUPPORTED_CHAINS_IDS;
  token: SUPPORTED_TOKENS;
  // Token address on source chain
  amount: number | string;
  recipient?: `0x${string}`;
  sourceChains?: number[];
  execute?: Omit<ExecuteParams, 'toChainId'>;
  enableTransactionPolling?: boolean;
  transactionTimeout?: number;
  // Global options for transaction confirmation
  waitForReceipt?: boolean;
  receiptTimeout?: number;
  requiredConfirmations?: number;
  // Optional recent approval transaction hash to consider in simulation
  recentApprovalTxHash?: string;
}
```

## Handling responses
The `bridgeAndExecute` method handles responses differently depending on the bridge protocol and chain configurations. Here's how to properly handle both scenarios.

### Synchronous response 

Some bridges (like those with instant finality or optimistic execution) provide immediate confirmation:
```typescript
try {

```
### Asynchronous response

Most cross-chain operations require waiting for destination chain finality:

```typescript

```

## Example

```typescript showLineNumbers filename="Typescript"
import type {
  ExecuteParams,
  ExecuteResult,
  ExecuteSimulation,
  BridgeAndExecuteParams,
  BridgeAndExecuteResult,
  BridgeAndExecuteSimulationResult,
} from '@avail-project/nexus-core';

// Execute contract functions with dynamic parameter builder - Compound V3 Supply
const result: ExecuteResult = await sdk.execute({
  toChainId: 1,
  contractAddress: '0xc3d688B66703497DAA19211EEdff47f25384cdc3', // Compound V3 USDC Market
  contractAbi: [
    {
      inputs: [
        { internalType: 'address', name: 'asset', type: 'address' },
        { internalType: 'uint256', name: 'amount', type: 'uint256' },
      ],
      name: 'supply',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  functionName: 'supply',
  buildFunctionParams: (
    token: SUPPORTED_TOKENS,
    amount: string,
    chainId: SUPPORTED_CHAINS_IDS,
    userAddress: `0x${string}`,
  ) => {
    const decimals = TOKEN_METADATA[token].decimals;
    const amountWei = parseUnits(amount, decimals);
    const tokenAddress = TOKEN_CONTRACT_ADDRESSES[token][chainId];
    return {
      functionParams: [tokenAddress, amountWei],
    };
  },
  waitForReceipt: true,
  requiredConfirmations: 3,
  tokenApproval: {
    token: 'USDC',
    amount: '1000000', // Amount in token units
  },
} as ExecuteParams);

// Simulate execute to preview costs and check for approval requirements
const simulation: ExecuteSimulation = await sdk.simulateExecute(executeParams);
if (!simulation.success) {
  console.log('Simulation failed:', simulation.error);
  // Error might indicate missing token approval
}

// Bridge tokens and execute contract function - Yearn Vault Deposit
const bridgeAndExecuteResult: BridgeAndExecuteResult = await sdk.bridgeAndExecute({
  token: 'USDC',
  amount: '100000000', // 100 USDC (6 decimals)
  toChainId: 1, // Ethereum
  sourceChains: [8453], // Only use USDC from `Base` as source for bridge
  execute: {
    contractAddress: '0xa354F35829Ae975e850e23e9615b11Da1B3dC4DE', // Yearn USDC Vault
    contractAbi: [
      {
        inputs: [
          { internalType: 'uint256', name: 'assets', type: 'uint256' },
          { internalType: 'address', name: 'receiver', type: 'address' },
        ],
        name: 'deposit',
        outputs: [{ internalType: 'uint256', name: 'shares', type: 'uint256' }],
        stateMutability: 'nonpayable',
        type: 'function',
      },
    ],
    functionName: 'deposit',
    buildFunctionParams: (
      token: SUPPORTED_TOKENS,
      amount: string,
      chainId: SUPPORTED_CHAINS_IDS,
      userAddress: `0x${string}`,
    ) => {
      const decimals = TOKEN_METADATA[token].decimals;
      const amountWei = parseUnits(amount, decimals);
      return {
        functionParams: [amountWei, userAddress],
      };
    },
    tokenApproval: {
      token: 'USDC',
      amount: '100000000',
    },
  },
  waitForReceipt: true,
} as BridgeAndExecuteParams);

// Comprehensive simulation with detailed step analysis and approval handling
const simulation: BridgeAndExecuteSimulationResult = await sdk.simulateBridgeAndExecute(params);

// The simulation provides detailed step analysis:
console.log('Steps:', simulation.steps);

console.log('Total estimated cost:', simulation.totalEstimatedCost);

console.log('Approval required:', simulation.metadata?.approvalRequired);
console.log('Bridge receive amount:', simulation.metadata?.bridgeReceiveAmount);
```

## Return Value

The return value is a `BridgeAndExecuteResult` object.

```typescript showLineNumbers filename="Typescript"
export interface BridgeAndExecuteResult {
  executeTransactionHash?: string;
  executeExplorerUrl?: string;
  approvalTransactionHash?: string;
  bridgeTransactionHash?: string; // undefined when bridge is skipped
  bridgeExplorerUrl?: string; // undefined when bridge is skipped
  toChainId: number;
  success: boolean;
  error?: string;
  bridgeSkipped: boolean; // indicates if bridge was skipped due to sufficient funds
}
```